# Script that generates files for importing models on the specified Platform

### Procedure to export PSM to specific platform
    ## 1. Get the current open model
    ## 2. Select path to export files
    ## 3. Execute platform specific procedure
PROCEDURE global PSM_TO_FILE
{
    ## 1.
    # Get current model
    CC "Modeling" GET_ACT_MODEL
    SET modelID:(modelid)
    IF (modelID = -1) {
        CC "AdoScript" WARNINGBOX ("Select a PSM model to proceed.")
        EXIT
    }
    # Check if current model is a PSM
    CC "Core" GET_ATTR_VAL objid:(modelID) attrname:("Model Type")
    IF (val != "PSM") {
        CC "AdoScript" WARNINGBOX ("Select a PSM model to proceed.")
        EXIT
    }

    ## 2.
    # Select the path to save files
    CC "AdoScript" DIRECTORY_DIALOG
    IF (endbutton != "ok") {
        EXIT
    }

    ## 3.
    # Get platform name
    CC "Core" GET_ATTR_VAL objid:(modelID) attrname:("Platform")
    SET platform:(val)
    # Choose export function
    IF (platform = "ThingsBoard") {
        THINGSBOARD modelID:(modelID) path:(path)
    } ELSIF (platform = "Losant") {
        LOSANT modelID:(modelID) path:(path)
    } ELSIF (platform = "Azure") {
        AZURE modelID:(modelID) path:(path)
    } ELSE {
        CC "AdoScript" WARNINGBOX ("Platform not supported.")
        EXIT
    }
}

PROCEDURE global AZURE 
modelID:integer # Source model's id
path:string # Path where to save files
{

	CC "Core" GET_MODEL_MODELTYPE modelid:(modelID)
    IF( modeltype = "IoT Logic") {
        AZURE_LOGIC path:(path)
        EXIT
    }

    CC "AdoScript" WARNINGBOX("Please ensure that there are no accented letters on devices, device's operations or attributes names.\nThey may cause import failure on Azure!")

    # Application name and device template name are used for the id buildings
    SET applicationURL: ""

    # Take all the model devices
    CC "AdoScript" EDITFIELD title:"Azure's Application subdomain" caption:"Enter Azure's Application subdomain:" text:"myazureapplication"
    IF (ecode != 0) {# if "ok" button is not clicked, something went wrong
        EXIT
    }
    SET applicationURL:(text)

    SET path:(path + "\\" + applicationURL)
    CC "AdoScript" DIR_CREATE path:(path)

    CC "Core" LOAD_MODEL modelid:(modelID)

    # for each device return a json file with the device's capabilities
    CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("device")

    # iterate over the devices, for each device create a <deviceName>_capabilities.json file
    FOR device in:(objids) {
        
        # The json file starts with the [] so we need to write first an array of objects (in this case, with only one "primary"-object)
        SET container:({})

        SETL primaryObject:(map()) # primaryObject: the only global object inserted into the json file, the only element of the "container" array 

        SET contents:({})   # array "contents" with many "capability" objects as the number of the device capabilities' 

        # Get the device's name
        CC "Core" GET_ATTR_VAL objid:(VAL device) attrname:("name")
        SET deviceName:(replall(val, " ", "")) # delete every space in between the device's name
        
        # fill "contents" array
        SET_CAPABILITIES contents:contents device:(VAL device)

        # @id & @type
        SETL primaryObject:({
            "@id":"dtmi:"+applicationURL+":"+deviceName+"_"+"123"+";"+"1",
            "@type":"Interface",
            "contents": contents,
            "displayName": {
                "en": deviceName
            },
            "@context":({
                "dtmi:iotcentral:context;2",   # version 2 by default: last number means version
                "dtmi:dtdl:context;2"
            })
        })

        SET filePath:(path + "\\"+deviceName+"_capabilities.json")

        # everything inside container (Azure json file format...)
        SET container:({primaryObject})

        #  final instructions
        SETL primaryObject:(lam_toJson(container))
        CC "AdoScript" FWRITE file:(filePath) text:(primaryObject)
    }    
}

# fill "contents" array on .json files generated from each device
PROCEDURE global SET_CAPABILITIES
contents:reference
device:integer
{
    # Get all the objects linked to this object (intially the object is a "device" object)
    CC "Core" GET_CONNECTORS objid:(device) out
    FOR connector in:(objids) {
        CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL connector)
        CC "Core" GET_CLASS_ID objid:(toobjid)
        CC "Core" GET_CLASS_NAME classid:(classid)
        # if it has "attribute", "Device Operation" or "location" objects linked to it, fill "contents" array (the one with all the capabilities)
        IF( classname = "attribute") {
            # Azure device template's capabilities of type "Telemetry": find these informations inside "Attribute" objects
            CC "Core" GET_ATTR_VAL objid:(toobjid) attrname:("name")
            SETL attributeName:(replall(val, " ", ""))
            CC "Core" GET_ATTR_VAL objid:(toobjid) attrname:("psm_type")
            SETL attributePsmType:(val)
            IF(attributePsmType="") {
                CC "AdoScript" WARNINGBOX ("psm_type not selected, "+attributeName+" .json file creation was aborted.\nObject id: "+ STR toobjid)
                NEXT
            }
            SETL attributeDescription:""
            CC "Core" GET_ATTR_VAL objid:(toobjid) attrname:("description")
            IF(val!="") {
                SETL attributeDescription:(val)
            }
            SETL newCapability:({
                "@id": "dtmi:"+applicationURL+":"+deviceName+"_123:"+attributeName+";1",
                "@type":({
                    "Telemetry",
                    "NumberValue",
                    attributePsmType
                }),
                "description":({
                    "en": attributeDescription
                }),
                "name": attributeName
            })
            SETL newCapability["name"]:(attributeName)
            SET_CAPABILITY_SCHEMA_AND_UNIT capability:newCapability attribute:toobjid
            SET nothing:(aappend(contents, newCapability))

        } ELSIF ( classname="Device Operation") {
            # Azure device template's capabilities of type "Command": find these informations inside "Device Operation" objects
            CC "Core" GET_ATTR_VAL objid:(toobjid) attrname:("name")
            SETL commandName:(replall(val, " ", ""))
            CC "Core" GET_ATTR_VAL objid:(toobjid) attrname:("description")
            SETL deviceOperationDescription:(val)

            SETL newCapability:({
                "@id":"dtmi:"+applicationURL+":"+deviceName+"_123:"+commandName+";1",
                "@type": "Command",
                "commandType": "synchronous",
                "description": ({
                    "en": deviceOperationDescription
                }),
                "name": commandName
            })

            SET nothing:(aappend(contents, newCapability))
        } ELSIF ( classname="location") {
            CC "Core" GET_ATTR_VAL objid:(toobjid) attrname:("description")
            SETL description:(val)
            SETL newCapability:({
                "@id": "dtmi:"+applicationURL+":"+deviceName+"_123:locationProperty;1",
                "@type":({
                    "Property",
                    "Location"
                }),
                "description":({
                    "en": description
                }),
                "name": "locationProperty",
                "schema": "geopoint"
            })
            SET nothing:(aappend(contents, newCapability))
        }
        # iterate over the "deeper" objects:
        #
        #    maybe some "attribute", "Device Operation" or "location" objects are not linked directly to the "device" object
        SET_CAPABILITIES contents:contents device:(toobjid)
    } 
}

# each telemetry has its own schema and unit ( it's better to work on each capability instead of working globally )
# it will be easier to insert more details in the future
PROCEDURE global SET_CAPABILITY_SCHEMA_AND_UNIT
capability:reference
attribute:reference
{
    CC "Core" GET_ATTR_VAL objid:(attribute) attrname:("psm_type")
    SETL specAttr:(val)

    SETL attributeSpecRecs:({})
    GET_SPECIFICATION_RECORDS objid:(attribute) specRecs:attributeSpecRecs

    # Get specification attributes
    IF(specAttr = "Acceleration") {
        SET capability["schema"]:"double"
        SET capability["unit"]:("metrePerSecondSquared")
        SET capability["maxValue"]:(VAL attributeSpecRecs[0])

    } ELSIF (specAttr = "Distance") {
        SET capability["schema"]:"integer"
        SET capability["unit"]:("metre")
        SET capability["maxValue"]:(VAL attributeSpecRecs[0])

    } ELSIF ( specAttr = "Humidity") {
        SET capability["schema"]:"double"

    } ELSIF ( specAttr = "Temperature") {
        SET capability["schema"]:"double"
        SET capability["unit"]:(attributeSpecRecs[0])

    } ELSIF ( specAttr = "Force") {
        SET capability["schema"]:"double"
        SET capability["unit"]:(attributeSpecRecs[0])

    } ELSIF ( specAttr = "Mass") {
        SET capability["schema"]:"double"
        SET capability["unit"]:(attributeSpecRecs[0])

    } ELSIF ( specAttr = "Area") {
        SET capability["schema"]:"double"
        SET capability["unit"]:(attributeSpecRecs[0])

    } ELSIF ( specAttr = "Pressure") {
        SET capability["schema"]:"double"
        SET capability["unit"]:(attributeSpecRecs[0])
    }
}


# Export all the "blue objects" (pubsub_out, datastream_out, storage, request_out, notification) in a json file.
# this creates n .json files as n "blue objects" present in this model

PROCEDURE global FIND_ROUTES
actions:reference
obj:integer
{
    CC "Core" GET_CONNECTORS objid:(obj) out
    FOR connector in:(objids) {
        CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL connector)
        CC "Core" GET_CLASS_ID objid:(toobjid)
        CC "Core" GET_CLASS_NAME classid:(classid)
        # if we found "storage", "data_stream_out", "pubsub_out" or "request_out" objects linked to it, fill "actions" array (the one with all the actions)
        IF(classname="storage" OR classname="data_stream_out" OR classname="pubsub_out" OR classname="request_out" ) {
            SETL dummy:(aappend(actions, STR toobjid))
        }
        # iterate
        #IF(toobjid != "") {
        FIND_ROUTES actions:actions obj:(toobjid) # vedere perche non esce mai
        #}
    } 
} 


# The rules defined in <yourapplication>.azureiotcentral.com have some actions linked to the LogicApp in portal.azure.com 
# each rule has its own application which define the actions to be executed when the rule is triggered (!!!!!!!!)

PROCEDURE global AZURE_LOGIC
path:string
{
    GET_SPECIFICATIONS platform: ("Azure") specs: specs

    CC "AdoScript" WARNINGBOX ("Please ensure that azureiotcentral, mongodb and servicebus API connections have been created!
        \n\nTo execute JS code check if an Integration account is in our logic application")

    CC "AdoScript" EDITFIELD title:"Azure's Logic Application name" caption:"Enter Azure's Logic Application name:" text:"azurelogicapplication"
    IF (ecode != 0) {# if "ok" button is not clicked, something went wrong
        EXIT
    }
    SET newLogicAppName:(text)

    SET path:(path + "\\" + newLogicAppName)
    CC "AdoScript" DIR_CREATE path:(path)

    CC "AdoScript" EDITFIELD title:"Azure's Logic main resource group name" caption:"Enter Azure's Logic main resource group name:" text:"resourcegroupname"
    IF (ecode != 0) {# if "ok" button is not clicked, something went wrong
        EXIT
    }
    SET mainResourceGroupName:(text)

    CC "AdoScript" EDITFIELD title:"Azure's Logic main subscription id" caption:"Enter Azure's Logic subscription id:" text:"subscrption-id"
    IF (ecode != 0) {# if "ok" button is not clicked, something went wrong
        EXIT
    }
    SET subscriptionId:(text)

    CC "AdoScript" EDITFIELD title:"Azure iot central application id" caption:"Enter Azure iot central application id:" text:"my-azure-iot-central-id"
    IF (ecode != 0) {# if "ok" button is not clicked, something went wrong
        EXIT
    }
    SETL applicationId: (text)
    
    # todo magari invece che controllare se ci sono piu connessioni api ad azure iot central o sendmessage o mongodb --> WARNINGBOX con scritto (make sure che ce sta un solo connessione api di ste cose)
    # forse in realtà manco ce sta bisogno: se ce n'è piu di una prendo la prima, che prob c'è (alla peggio ce n'è 2 e viene eliminata la prima)

    CC "AdoScript" EDITFIELD title:"Azure iot central main rule id" caption:"Enter Azure iot central main rule id:" text:"azure-iot-central-rule-id"
    IF (ecode != 0) {# if "ok" button is not clicked, something went wrong
        EXIT
    }
    SETL ruleId: (text)

    # useful for "aggregation", "scripting" and "formatting" objects --> in Azure Logic App they're converted in "Execute JavaScript code"
    CC "AdoScript" EDITFIELD title:"Integration account name" caption:"Enter Integration account name:" text:"IntegrationAccountName"
    IF (ecode != 0) {# if "ok" button is not clicked, something went wrong
        EXIT
    }
    SETL integrationAccountName:(text)

    # in futuro utilizzare CLASS_PSM anziche' procedere in questa maniera (map create "manualmente" e non tramite il contenuto di azure.json)
    # creare e inserire actions per i datastream_in                 mike da prendere da "config" del file azure.json

    SET_PARAMETERS_PRESETS

    SETL arrayMap:(map())
    SET actionsArrayMap:(map())

    # maybe in future find a way to iterate for each "green object" instead of only "data_stream_in" objects
    CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("data_stream_in")
    # check if a data_stream_in object has incoming connector, it shouldn't
    FOR dsi in:(objids) {
        # exception handling
        CC "Core" GET_CONNECTORS objid:(VAL dsi) in
        IF(objids.empty != 1) {
            CC "AdoScript" ERRORBOX ("data_stream_in object with id "+dsi+" has incoming connectors")
            EXIT
        }
        
        SETL dsiSpecRecs:({})
        GET_SPECIFICATION_RECORDS objid:(VAL dsi) specRecs:dsiSpecRecs
        CC "Core" GET_ATTR_VAL objid:(VAL dsi) attrname:("name")
        SETL dsiName:(val)

        IF(dsiName="") {
            SETL dsiName:(dsiSpecRecs[0])
        }

        SET dsiAction:({ 
            "runAfter": (map()),
            "type": "ApiConnection",
            "inputs": {
                "host": {
                    "connection": {
                        "name": "@parameters('$connections')['azureiotcentral']['connectionId']"
                    }
                },
                "method": "get",
                "path": "/api/v1/devices/@{encodeURIComponent('"+dsiName+"')}/telemetry/@{encodeURIComponent('["+dsiName+"]')}",
                "queries": {
                    "application": applicationId
                }
            }
        })

        # append this action to the actions map
        SET actionsArrayMap[dsiName]:(dsiAction)

        SET previousAction:(dsiName)
        
        TO_THE_END currentObj:(VAL dsi) arrayMap:actionsArrayMap
        # the only problem comes when there are 2 "filtering" objects linked: there's not a way in Azure Logic App to create parallel "Condition" object
    }

    SETL defaultTrigger:(map())
    DEFAULT_TRIGGER triggers:defaultTrigger ruleId:(ruleId)
    CREATE_NEW_FILE actions:(actionsArrayMap) triggers:(defaultTrigger) parametersSection:(allParametersSection) parameters:(allParameters)
    EXIT
} 

PROCEDURE global TO_THE_END
currentObj:integer
arrayMap:reference
{
    CC "Core" GET_CONNECTORS objid:(currentObj) out
    SETL outcomingConnectors:(objids)
    SETL isEditable:(tokcnt(outcomingConnectors, " "))  # don't know why should have to use this...
    SETL runAfter:(map())

    CC "Core" GET_ATTR_VAL objid:(currentObj) attrname:("name")
    SETL previousAction:(val)

    CC "Core" GET_CLASS_ID objid:(currentObj)
    CC "Core" GET_CLASS_NAME classid:(classid)            
    IF(classname="filtering") {
        SETL runAfter:(map())
    } ELSE {
        SETL runAfter[previousAction]:({"Succeeded"})
    }
        FOR connid in:(objids) {
            CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL connid)
            SETL objToChange:(toobjid)
            CC "Core" GET_CLASS_ID objid:(objToChange)
            CC "Core" GET_CLASS_NAME classid:(classid)            
            CC "Core" GET_ATTR_VAL objid:(objToChange) attrname:("name")
            SETL objName:(val)
            IF( classname = "aggregation" OR classname ="formatting" OR classname="scripting") {
                # check if psm_type is selected
                CC "Core" GET_ATTR_VAL objid:(objToChange) attrname:("psm_type")
                IF( val = "") {
                    NEXT
                }
                SETL exJSSpecRecs:({})
                GET_SPECIFICATION_RECORDS objid:(objToChange) specRecs:exJSSpecRecs
                SETL executeJSCodeAction:(map())
                GET_EXECUTE_JS_CODE_ACTION executeJSCodeAction:executeJSCodeAction runAfter:(runAfter) yellowSpecRecs:(exJSSpecRecs)
                SETL arrayMap[objName]:(executeJSCodeAction)
            } ELSIF(classname="filtering") {
                # check if psm_type is selected
                CC "Core" GET_ATTR_VAL objid:(objToChange) attrname:("psm_type")
                IF( val = "") {
                    EXIT    # abort the process 
                }
                SETL filteringActions:(map())
                TO_THE_END currentObj:(objToChange) arrayMap:filteringActions  # set filtering actions apart
                SETL filteringSpecRecs:({})
                GET_SPECIFICATION_RECORDS objid:(objToChange) specRecs:filteringSpecRecs

                SETL filteringAction:({
                    "actions": filteringActions,
                    "runAfter": runAfter,
                    "expression": {
                        "and": ({
                            {
                                filteringSpecRecs[0]: ({
                                    "@body('"+previousAction+"')?['value']",
                                    (VAL filteringSpecRecs[1])
                                })
                            }
                        })
                    },
                    "type": "If" 
                })

                SET arrayMap[objName]:(filteringAction)
                EXIT
            } ELSIF(classname="storage") {
                CC "Core" GET_ATTR_VAL objid:(objToChange) attrname:("psm_type")
                IF( val = "") {
                    NEXT
                }
                SETL storageTypeSelected:(val)
                SETL stoargeSpecRecs:({})
                GET_SPECIFICATION_RECORDS objid:(objToChange) specRecs:stoargeSpecRecs
                IF(storageTypeSelected="Insert_Document") {
                    SETL insertDocumentAction:(map())
                    GET_INSERT_DOCUMENT_ACTION insertDocumentAction:insertDocumentAction runAfter:(runAfter) stoargeSpecRecs:(stoargeSpecRecs)
                    # if the map is empty some important fields in "storageSpecRecs" are empty 
                    IF(insertDocumentAction.empty = 1) {
                        NEXT
                    }
                    SETL arrayMap[objName]:(insertDocumentAction)
                } IF(storageTypeSelected="Create_or_update_a_device") {
                    SETL createOrUpdateDeviceAction:(map())
                    GET_CREATE_OR_UPDATE_DEVICE_ACTION createOrUpdateDeviceAction:createOrUpdateDeviceAction runAfter:(runAfter) stoargeSpecRecs:(stoargeSpecRecs)
                    SET arrayMap[objName]:(createOrUpdateDeviceAction)
                }
            } ELSIF(classname="data_stream_out") {
                CC "Core" GET_ATTR_VAL objid:(objToChange) attrname:("psm_type")
                IF( val = "") {
                    NEXT
                }
                SETL dataStreamOutSpecRecs:({})
                GET_SPECIFICATION_RECORDS objid:(objToChange) specRecs:dataStreamOutSpecRecs

                SETL runADeviceCommandAction:(map())
                GET_RUN_A_DEVICE_COMMAND_ACTION runADeviceCommandAction:runADeviceCommandAction runAfter:(runAfter) dataStreamOutSpecRecs:(dataStreamOutSpecRecs)
                IF(runADeviceCommandAction.empty = 1) {
                    NEXT
                }
                SET arrayMap[objName]:(runADeviceCommandAction)
            } ELSIF(classname="request_out") {
                CC "Core" GET_ATTR_VAL objid:(objToChange) attrname:("psm_type")
                # parameters exception handling
                IF( val = "") {
                    CC "AdoScript" WARNINGBOX ("psm_type not selected, "+objName+" .json file creation was aborted.")
                    NEXT
                }
                SETL httpMethod:(val)
                SETL requestOutSpecRecs:({})
                GET_SPECIFICATION_RECORDS objid:(objToChange) specRecs:requestOutSpecRecs
                SET dummy:(aappend(requestOutSpecRecs, httpMethod))
                SETL httpAction:(map())
                GET_HTTP_ACTION httpAction:httpAction runAfter:(runAfter) requestOutSpecRecs:(requestOutSpecRecs) 
                IF(httpAction.empty = 1) {
                    NEXT
                }
                SET arrayMap[objName]:(httpAction)
            } ELSIF(classname="pubsub_out") {
                CC "Core" GET_ATTR_VAL objid:(objToChange) attrname:("psm_type")
                IF( val = "") {
                    NEXT
                }
                SETL pubsubOutSpecRecs:({})
                GET_SPECIFICATION_RECORDS objid:(objToChange) specRecs:pubsubOutSpecRecs
                SETL sendMessageAction:(map())
                GET_SEND_MESSAGE_ACTION sendMessageAction:sendMessageAction runAfter:(runAfter) pubsubOutSpecRecs:(pubsubOutSpecRecs)
                IF(sendMessageAction.empty = 1) {
                    NEXT
                }
                SET arrayMap[objName]:(sendMessageAction)
            }
            TO_THE_END currentObj:(objToChange) arrayMap:arrayMap
        }
}


# AZURE LOGIC APP --- Main .json structure, flexible structure, todo in future: could be more and more accurated for each detail
# the parameters received are good, there's no need to check their reliability
PROCEDURE global CREATE_NEW_FILE
actions:map   # actions to be inserted
triggers:map
parametersSection:map
parameters:map
{   
    SETL finalObject:({
        "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
        "contentVersion": "1.0.0.0",
        "parameters": parametersSection,
        "variables": map(),   # forse questo in futuro potra essere cambiato
        "resources": 
            ({({
                "type": "Microsoft.Logic/workflows",
                "apiVersion": "2017-07-01",
                "name": "[parameters('workflows_"+newLogicAppName+"_name')]",
                "location": "francesouth",
                "tags": {
                    "ms-resource-usage": "azure-cloud-shell"
                },
                "properties": {
                    "state": "Enabled",
                    "integrationAccount": {
                        "id": "[parameters('integrationAccounts_"+integrationAccountName+"_externalid')]"
                    },
                    "definition": {
                        "$schema": "https://schema.management.azure.com/providers/Microsoft.Logic/schemas/2016-06-01/workflowdefinition.json#",
                        "contentVersion": "1.0.0.0",
                        "parameters": {
                            "$connections": {
                                "defaultValue": map(),
                                "type": "Object"
                            }
                        },
                        "triggers": triggers,
                        "actions": actions,
                        "outputs": map()
                    },
                    "parameters": {
                        "$connections": {
                            "value": parameters
                        }
                    }
                }
            })})
    })
            

    # 3. fill the new .json with the json structure informations and this model parameters
    SETL primaryObject:(lam_toJson(finalObject))

    SET filePath:(path + "\\"+newLogicAppName+".json")
    CC "AdoScript" FWRITE file:(filePath) text:(primaryObject)
}


# AZURE LOGIC APP ---
# todo: maybe in future there will be the opportunity to have multiple triggers (at the same time), for now it's inconvenient or (at least as I understood) 
# available only with time recurrency by command prompt (ex: each 3 minutes do this)  
PROCEDURE global DEFAULT_TRIGGER
triggers:reference   # output reference
ruleId:string
{
    SETL triggers:({
            "When_a_rule_is_fired": {
                "type": "ApiConnectionWebhook",
                "inputs": {
                    "body": {
                        "rule": ruleId,
                        "url": "@{listCallbackUrl()}"
                    },
                    "host": {
                        "connection": {
                            "name": "@parameters('$connections')['azureiotcentral']['connectionId']"
                        }
                    },
                    "path": "/api/preview/_internal/workflow/triggers",
                    "queries": {
                        "application": applicationId    # initialized at the start of the file
                    }
                }
            }
    })
}

# AZURE LOGIC APP --- set useful parameters and parameters section for json files production.
#   put these parameters in the final structure, take a look at "CREATE_NEW_FILE"
PROCEDURE global SET_PARAMETERS_PRESETS
{
    SETG allParameters:({
        "azureiotcentral": {
            "connectionId": "[parameters('connections_azureiotcentral_externalid')]",
            "connectionName": "azureiotcentral",
            "id": "/subscriptions/"+subscriptionId+"/providers/Microsoft.Web/locations/francesouth/managedApis/azureiotcentral"
        },
        "mongodb": {
            "connectionId": "/subscriptions/"+subscriptionId+"/resourceGroups/nuovoResourceGroup/providers/Microsoft.Web/connections/mongodb",
            "connectionName": "mongodb",
            "id": "/subscriptions/"+subscriptionId+"/providers/Microsoft.Web/locations/francesouth/managedApis/mongodb"
        },
        "servicebus": {
            "connectionId": "/subscriptions/"+subscriptionId+"/resourceGroups/nuovoResourceGroup/providers/Microsoft.Web/connections/servicebus",
            "connectionName": "servicebus",
            "id": "/subscriptions/"+subscriptionId+"/providers/Microsoft.Web/locations/francesouth/managedApis/servicebus"
        }
    })

    SETG allParametersSection:({
        "workflows_"+newLogicAppName+"_name": {
            "defaultValue": newLogicAppName,
            "type": "String"
        },
        "connections_azureiotcentral_externalid": {
            "defaultValue": "/subscriptions/"+subscriptionId+"/resourceGroups/"+mainResourceGroupName+"/providers/Microsoft.Web/connections/azureiotcentral",
            "type": "String"
        },
        "connections_mongodb_externalid": {
            "defaultValue": "/subscriptions/"+subscriptionId+"/resourceGroups/"+mainResourceGroupName+"/providers/Microsoft.Web/connections/mongodb",
            "type": "String"
        },
        "connections_servicebus_externalid": {
            "defaultValue": "/subscriptions/"+subscriptionId+"/resourceGroups/"+mainResourceGroupName+"/providers/Microsoft.Web/connections/servicebus",
            "type": "String"
        },
        "integrationAccounts_"+integrationAccountName+"_externalid": { # integration account require the name -> it's not incremental as the other parameters
            "defaultValue": "/subscriptions/"+subscriptionId+"/resourceGroups/"+mainResourceGroupName+"/providers/Microsoft.Logic/integrationAccounts/"+integrationAccountName,
            "type": "String"
        }
    })

    # permanent api connection... the one which permits "when_a_rule_is_fired"
    SETG onlyAzureIotCentralParameter:({
        "azureiotcentral": {
            "connectionId": "[parameters('connections_azureiotcentral_externalid')]",
            "connectionName": "azureiotcentral",
            "id": "/subscriptions/"+subscriptionId+"/providers/Microsoft.Web/locations/francesouth/managedApis/azureiotcentral"
        }
    })

    SETG onlyAzureIotCentralParameterSection:({
        "workflows_"+newLogicAppName+"_name": {
            "defaultValue": newLogicAppName,                    # this part is identical for each json that will be created
            "type": "String"
        },
        "connections_azureiotcentral_externalid": {
            "defaultValue": "/subscriptions/"+subscriptionId+"/resourceGroups/"+mainResourceGroupName+"/providers/Microsoft.Web/connections/azureiotcentral",
            "type": "String"
        }
    })

    SETG serviceBus_AzureIotCentralParameter:({
        "azureiotcentral": {
            "connectionId": "[parameters('connections_azureiotcentral_externalid')]",
            "connectionName": "azureiotcentral",
            "id": "/subscriptions/"+subscriptionId+"/providers/Microsoft.Web/locations/francesouth/managedApis/azureiotcentral"
        },
        "servicebus": {
            "connectionId": "[parameters('connections_servicebus_externalid')]",
            "connectionName": "servicebus",
            "id": "/subscriptions/"+subscriptionId+"/providers/Microsoft.Web/locations/francesouth/managedApis/servicebus"
        }
    })

    SETG serviceBus_AzureIotCentralParameterSection:({
        "workflows_"+newLogicAppName+"_name": {
            "defaultValue": newLogicAppName,
            "type": "String"
        },
        "connections_azureiotcentral_externalid": {
            "defaultValue": "/subscriptions/"+subscriptionId+"/resourceGroups/"+mainResourceGroupName+"/providers/Microsoft.Web/connections/azureiotcentral",
            "type": "String"
        },
        "connections_servicebus_externalid": {
            "defaultValue": "/subscriptions/"+subscriptionId+"/resourceGroups/nuovoResourceGroup/providers/Microsoft.Web/connections/servicebus",
            "type": "String"
        }
    })

    SETG mongoDB_AzureIotCentralParameter:({
        "azureiotcentral": {
            "connectionId": "[parameters('connections_azureiotcentral_externalid')]",
            "connectionName": "azureiotcentral",
            "id": "/subscriptions/"+subscriptionId+"/providers/Microsoft.Web/locations/francesouth/managedApis/azureiotcentral"
        },
        "mongodb": {
            "connectionId": "[parameters('connections_mongodb_externalid')]",
            "connectionName": "mongodb",
            "id": "/subscriptions/"+subscriptionId+"/providers/Microsoft.Web/locations/francesouth/managedApis/mongodb"
        }
    })

    SETG mongoDB_AzureIotCentralParameterSection:({
        "workflows_"+newLogicAppName+"_name": {
            "defaultValue": newLogicAppName,
            "type": "String"
        },
        "connections_azureiotcentral_externalid": {
            "defaultValue": "/subscriptions/"+subscriptionId+"/resourceGroups/"+mainResourceGroupName+"/providers/Microsoft.Web/connections/azureiotcentral",
            "type": "String"
        },
        "connections_mongodb_externalid": {
            "defaultValue": "/subscriptions/"+subscriptionId+"/resourceGroups/nuovoResourceGroup/providers/Microsoft.Web/connections/mongodb",
            "type": "String"
        }
    })

}

# get object's "specification" records' values
PROCEDURE global GET_SPECIFICATION_RECORDS
objid:integer
specRecs:reference  # array of specification's records to be passed
{
    CC "Core" GET_CLASS_ID objid:(objid)
    CC "Core" GET_ATTR_ID classid:(classid) attrname:("specification")
    CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(objid) attrid:(attrid)

    # insert all the output records in specRecs array
    SET specRecs:({})
    # get specs val
    FOR row in:(rowids) {
        CC "Core" GET_ATTR_VAL objid:(VAL row) attrname:("Value")
        SET blablabla:(aappend(specRecs, val))
    }
}


### ThingsBoard export function
PROCEDURE global THINGSBOARD
    modelID:integer # Source model's id
    path:string # Path where save files
{
    ## 1.
    # Get specifications
    SET convJson:("")
    GET_SPECIFICATIONS platform:("ThingsBoard") specs:convJson

    ## 2.
    # Set application name
    CC "AdoScript" EDITFIELD title:"Enter application name" caption:"Application ~name:" text:"Default"
    IF (ecode = 1) {
        EXIT
    }
    SET path:(path + "\\" + text)
    CC "AdoScript" DIR_CREATE path:(path)

    ## 3.
    # Get the modeltype of the model
    CC "Core" GET_MODEL_MODELTYPE modelid:(modelID)

    IF (modeltype = "IoT Scenario") {
        SET device_profile:({
            "default": 0,
            "defaultQueueName": "",
            "description": "",
            "name": "",
            "profileData": {
                "configuration": {
                    "type": "DEFAULT"
                },
                "provisionConfiguration": {
                    "type": "DISABLED"
                },
                "transportConfiguration": {
                    "deviceAttributesTopic": "v1/devices/me/attributes",
                    "deviceTelemetryTopic": "v1/devices/me/telemetry",
                    "transportPayloadTypeConfiguration": {
                        "transportPayloadType": "JSON"
                    },
                    "type": "MQTT"
                }
            },
            "provisionType": "DISABLED",
            "transportType": "MQTT",
            "type": "DEFAULT"
        })
        SET dashboard:({
            "name": "Dashboard",
            "title": "Dashboard",
            "configuration": {
                "description": "",
                "widgets": map()
            },
            "states": {
                "default": {
                    "name": "Dashboard",
                    "layouts": {
                        "main": {
                            "widgets": {
                            },
                            "gridSettings": {
                                "backgroundColor": "#eeeeee",
                                "columns": 24,
                                "margin": 10,
                                "backgroundSizeMode": "100%"
                            }
                        }
                    }
                }
            },
            "timewindow": {
                "displayValue": "",
                "selectedTab": 0,
                "realtime": {
                    "realtimeType": 0,
                    "interval": 1000,
                    "timewindowMs": 60000,
                    "quickInterval": "CURRENT_DAY"
                },
                "history": {
                    "historyType": 0,
                    "interval": 1000,
                    "timewindowMs": 60000,
                    "fixedTimewindow": {
                        "startTimeMs": 1647250508451,
                        "endTimeMs": 1647336908451
                    },
                    "quickInterval": "CURRENT_DAY"
                },
                "aggregation": {
                    "type": "AVG",
                    "limit": 2500
                }
            }
        })

        SET attributes:(map())
        SET objAttributes:(map())

        # Get all attributes
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("attribute")
        FOR obj in:(objids) {
            CC "Core" GET_CONNECTORS objid:(VAL obj)
            IF (objids != "") {
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("name")
                SET attributes[val]:("")
                FOR connector in:(objids) {
                    CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL connector)
                    IF (type(objAttributes[fromobjid]) != "map") {
                        SET objAttributes[fromobjid]:(map())
                    }
                    SET map:(objAttributes[fromobjid])
                    SET key:(val)
                    CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("value")
                    SET map[key]:(val)
                    SET objAttributes[fromobjid]:(map)
                }
            }
        }

        # Get all locations
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("location")
        FOR obj in:(objids) {
            CC "Core" GET_CONNECTORS objid:(VAL obj)
            IF (objids != "") {
                SET attributes["lat"]:("")
                SET attributes["lon"]:("")
                FOR connector in:(objids) {
                    CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL connector)
                    IF (type(objAttributes[fromobjid]) != "map") {
                        SET objAttributes[fromobjid]:(map())
                    }
                    SET map:(objAttributes[fromobjid])
                    CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("lat")
                    SET map["lat"]:(val)
                    CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("lon")
                    SET map["lon"]:(val)
                    SET objAttributes[fromobjid]:(map)
                }
            }
        }

        # Get all device profiles
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("service")
        FOR obj in:(objids) {
            CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("name")
            SET device_profile["name"]:(val)
            CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("description")
            SET device_profile["description"]:(val)
            CC "AdoScript" FWRITE file:(path + "\\device_profile_" + obj + ".json") text:(STR device_profile)
        }

        # Get all devices
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("device")
        SET csv:("")
        SET attributes["name"]:("")
        SET attributes["description"]:("")
        FOR obj in:(objids) {
            SET objMap:(attributes)
            CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("name")
            SET objMap["name"]:(val)
            CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("description")
            SET objMap["description"]:(val)
            CC "Core" GET_CLASS_ID objid:(VAL obj)
            CC "Core" GET_ATTR_ID classid:(classid) attrname:("specification")
            CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(VAL obj) attrid:(attrid)
            # Get specification attributes
            FOR row in:(rowids) {
                CC "Core" GET_ATTR_VAL objid:(VAL row) attrname:("Attribute")
                SET key:(val)
                CC "Core" GET_ATTR_VAL objid:(VAL row) attrname:("Value")
                SET objMap[key]:(val)
            }
            # Get other attributes (attribute & location)
            IF (type(objAttributes[VAL obj]) = "map") {
                SET attrs:(objAttributes[VAL obj])
                FOR attr in:(replall(mapKeysList(objAttributes[VAL obj]), "~", " ")) {
                    SET objMap[attr]:(attrs[attr])
                }
            }
            # Add device line on csv
            SET columns:(mapKeysArray(objMap))
            FOR c from:0 to:(objMap.length-1) by:1 {
                IF (c = 0) {
                    SET csv:(csv + "\n" + objMap[columns[c]])
                } ELSE {
                    SET csv:(csv + "," + objMap[columns[c]])
                }
            }
        }
        SET columns:(replall(mapKeysList(objMap), "~", ","))
        SET csv:(columns + csv)
        CC "AdoScript" FWRITE file:(path + "\\devices.csv") text:(csv)

        # Get all systems
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("system")
        SET csv:("")
        FOR obj in:(objids) {
            SET objMap:(attributes)
            CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("name")
            SET objMap["name"]:(val)
            CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("description")
            SET objMap["description"]:(val)
            CC "Core" GET_CLASS_ID objid:(VAL obj)
            CC "Core" GET_ATTR_ID classid:(classid) attrname:("specification")
            CC "Core" GET_ALL_REC_ATTR_ROW_IDS objid:(VAL obj) attrid:(attrid)
            # Get specification attributes
            FOR row in:(rowids) {
                CC "Core" GET_ATTR_VAL objid:(VAL row) attrname:("Attribute")
                SET key:(val)
                CC "Core" GET_ATTR_VAL objid:(VAL row) attrname:("Value")
                SET objMap[key]:(val)
            }
            # Get other attributes (attribute & location)
            IF (type(objAttributes[VAL obj]) = "map") {
                SET attrs:(objAttributes[VAL obj])
                FOR attr in:(replall(mapKeysList(objAttributes[VAL obj]), "~", " ")) {
                    SET objMap[attr]:(attrs[attr])
                }
            }
            # Add asset line on csv
            SET columns:(mapKeysArray(objMap))
            FOR c from:0 to: (objMap.length-1) by:1 {
                IF (c = 0) {
                    SET csv:(csv + "\n" + objMap[columns[c]])
                } ELSE {
                    SET csv:(csv + "," + objMap[columns[c]])
                }
            }
        }
        SET columns:(replall(mapKeysList(objMap), "~", ","))
        SET csv:(columns + csv)
        CC "AdoScript" FWRITE file:(path + "\\assets.csv") text:(csv)

        # Get all widgets
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("widget")
        SET widgetId:(randomDiscreteUniformDist(10000000, 90000000))
        FOR obj in:(objids) {
            SET class:(map())
            CLASS_PSM specs:(convJson) objID:(VAL obj) class:class
            IF (NOT class.empty) {
                SET id:(STR widgetId)
                SET widgetId:(widgetId + 1)
                SET widget:(class["config"])
                SET widget["id"]:(id)
                SET widgetConfig:(widget["config"])
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("name")
                SET widgetConfig["title"]:(val)
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("description")
                SET widget["description"]:(val)
                SET widget["config"]:(widgetConfig)
                SET configuration:(dashboard["configuration"])
                SET widgets:(configuration["widgets"])
                SET widgets[id]:(widget)
                SET configuration["widgets"]:(widgets)
                SET dashboard["configuration"]:(configuration)
            }
        }
        CC "AdoScript" FWRITE file:(path + "\\dashboard.json") text:(lam_toJson(dashboard))
        
    } ELSIF (modeltype = "IoT Logic") {
        # Set rule chain name
        CC "AdoScript" EDITFIELD title:"Enter rule chain name" caption:"Rule chain ~name:" text:"Default"
        IF (ecode = 1) {
            EXIT
        }
        SET rulechainName:(text)
        SET rulechain:({
            "ruleChain": {
                "additionalInfo": {
                    "description": ""
                },
                "name": rulechainName,
                "type": "CORE"
            },
            "metadata": {
                "nodes": {},
                "connections": {}
            }
        })
        SET nodeIndex:(map())

        # Get all logic nodes
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("node")
        # Add nodes to rule chain file
        FOR obj in:(objids) {
            SET class:(map())
            CLASS_PSM specs:(convJson) objID:(VAL obj) class:class
            IF (NOT class.empty) {
                SET metadata:(rulechain["metadata"])
                SET nodes:(metadata["nodes"])
                SET node:(map())
                SET info:(map())
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("name")
                SET node["name"]:(val)
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("description")
                SET info["description"]:(val)
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:"Position"
                LEO parse:(val) get-tmm-value:x:"x" get-tmm-value:y:"y"
                SET info["layoutX"]:((CMS x)*50+100)
                SET info["layoutY"]:((CMS y)*50)
                SET node["additionalInfo"]:(info)
                SET node["type"]:(class["config"]["type"])
                SET n:(aappend(nodes, node))
                SET metadata["nodes"]:(nodes)
                SET rulechain["metadata"]:(metadata)
                SET nodeIndex[VAL obj]:(nodeIndex.length)
            }
        }

        # Get all logic connectors
        CC "Core" GET_ALL_CONNECTORS modelid:(modelID)
        # Add connectors to rule chain file
        FOR obj in:(objids) {
            CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("psm_type")
            CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL obj)
            IF (val != "" AND type(nodeIndex[toobjid]) != "undefined" AND type(nodeIndex[fromobjid]) != "undefined") {
                SET connection:(map())
                SET connection["type"]:(val)
                SET connection["toIndex"]:(nodeIndex[toobjid])
                SET connection["fromIndex"]:(nodeIndex[fromobjid])
                SET metadata:(rulechain["metadata"])
                SET connections:(metadata["connections"])
                SET n:(aappend(connections, connection))
                SET metadata["connections"]:(connections)
                SET rulechain["metadata"]:(metadata)
            }
        }

        SET json:(lam_toJson(rulechain))
        CC "AdoScript" FWRITE file:(path + "\\" + rulechainName + ".json") text:(lam_toJson(rulechain))
    }
}


### Losant export function
PROCEDURE global LOSANT
    modelID:integer # Source model's id
    path:string # Path where save files
{
    ## 1.
    # Get specifications
    SET convJson:("")
    GET_SPECIFICATIONS platform:("Losant") specs:convJson

    ## 2.
    # Set application name
    CC "AdoScript" EDITFIELD title:"Enter application name" caption:"Application ~name:" text:"Default"
    IF (ecode = 1) {
        EXIT
    }
    SET applicationName:(text)

    ## 3.
    # Get the modeltype of the model
    CC "Core" GET_MODEL_MODELTYPE modelid:(modelID)

    IF (modeltype = "IoT Scenario") {
        SET applicationId:("~exportplaceholderid-application-demo-0~")
        SET application:({
            "resourceType": "Application",
            "resources": {
                {
                    "blobUrlTTL": 86400,
                    "description": "",
                    "filesPath": "./files",
                    "globals": {},
                    "id": applicationId,
                    "name": "",
                    "readmePath": "./README.md"
                }
            },
            "version": 1
        })
        SET dashboard:({
            "resourceType": "Dashboard",
            "resources": {
                {
                    "blocks": {},
                    "contextConfiguration": {},
                    "defaultTheme": "light",
                    "description": "",
                    "id": "~exportplaceholderid-dashboard-dashboard-0~",
                    "name": "Dashboard",
                    "refreshRate": 60
                }
            },
            "version": 1
        })
        SET devices:({
            "resourceType": "DeviceTree",
            "resources": {},
            "version": 1
        })

        SET appDetails:(application["resources"])
        SET appResources:(appDetails[0])
        SET appResources["name"]:(applicationName)
        SET appResources["description"]:(applicationName + " application")
        SET appDetails[0]:(appResources)
        SET application["resources"]:(appDetails)

        # Get all systems and devices
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("system")
        SET systemids:(objids)
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("device")
        SET systemids:(systemids + " " + objids)
        SET struct:(map())
        SET resources:({})
        FOR systemid in:(systemids) {
            SET check:(0)
            CC "Core" GET_CONNECTORS objid:(VAL systemid) in
            FOR connid in:(objids) {
                CC "Core" GET_CLASS_ID relation objid:(VAL connid)
                CC "Core" GET_CLASS_NAME classid:(classid)
                IF (classname = "subsystem" OR classname = "hasDevice") {
                    SET check:(1)
                }
            }
            IF (check = 0) {
                LOSANT_DEVICES objID:(VAL systemid) struct:struct
                IF (struct.empty = 0) {
                    SET n:(aappend(resources, struct))
                }
            }
        }
        SET devices["resources"]:(resources)

        # Get all widgets
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("widget")
        SET dashboardResources:(dashboard["resources"])
        SET resources:(dashboardResources[0])
        SET height:(0)
        FOR widgetid in:(objids) {
            SET class:(map())
            CLASS_PSM specs:(convJson) objID:(VAL widgetid) class:class
            IF (NOT class.empty) {
                # Get widget's information
                SET widgets:(resources["blocks"])
                SET widget:(class["config"])
                SET widget["id"]:(widgetid)
                SET widget["applicationId"]:(applicationId)
                SET widget["startY"]:(height)
                CC "Core" GET_ATTR_VAL objid:(VAL widgetid) attrname:("name")
                SET widget["title"]:(val)
                SET n:(aappend(widgets, widget))
                SET resources["blocks"]:(widgets)
                SET dashboardResources[0]:(resources)
                SET dashboard["resources"]:(dashboardResources)
                SET height:(height + widget["height"])
            }
        }

        # Create application's files
        SET path:(path + "\\" + applicationName)
        CC "AdoScript" DIR_CREATE path:(path)
        CC "AdoScript" FWRITE file:(path + "\\application.json") text:(lam_toJson(application))
        CC "AdoScript" FWRITE file:(path + "\\devices.json") text:(lam_toJson(devices))
        SET path:(path + "\\dashboards")
        CC "AdoScript" DIR_CREATE path:(path)
        CC "AdoScript" FWRITE file:(path + "\\dashboard.json") text:(lam_toJson(dashboard))
    } ELSIF (modeltype = "IoT Logic") {
        # Set workflow name
        CC "AdoScript" EDITFIELD title:"Enter workflow name" caption:"Workflow ~name:" text:"Default"
        IF (ecode = 1) {
            EXIT
        }
        SET workflowName:(text)
        SET workflow:({
            "resourceType": "Flow",
            "resources": {
                {
                    "description": "",
                    "flowClass": "cloud",
                    "globals": {},
                    "id": "~exportplaceholderid-flow-workflow-0~",
                    "name": workflowName,
                    "nodes": {},
                    "triggers": {}
                }
            },
            "version": 1
        })
        
        # Get all logic nodes
        CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(modelID) classname:("node")
        SET workflowResources:(workflow["resources"])
        SET resources:(workflowResources[0])
        # Add nodes to rule chain file
        FOR obj in:(objids) {
            SET class:(map())
            CLASS_PSM specs:(convJson) objID:(VAL obj) class:class
            IF (NOT class.empty) {
                # Get node's information
                SET triggers:(resources["triggers"])
                SET nodes:(resources["nodes"])
                SET node:(class["config"])
                SET meta:(node["meta"])
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("name")
                SET meta["label"]:(val)
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("description")
                SET meta["description"]:(val)
                CC "Core" GET_ATTR_VAL objid:(VAL obj) attrname:("Position")
                LEO parse:(val) get-tmm-value:x:"x" get-tmm-value:y:"y"
                SET meta["x"]:((CMS x)*40)
                SET meta["y"]:((CMS y)*50)
                
                # Get node's out connectors
                IF (type(class["output"]) = "array") {
                    SET outputs:(map())
                    FOR i from:0 to:(class["output"].length-1) {
                        SET outputs[class["output"][i]]:({}) 
                    }
                    CC "Core" GET_CONNECTORS objid:(VAL obj) out
                    SET connids:(objids)
                    FOR connid in:(connids) {
                        CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL connid)
                        CC "Core" GET_ATTR_VAL objid:(VAL connid) attrname:("psm_type")
                        SET conntype:(val)
                        SET outputClass:("")
                        CLASS_PSM specs:(convJson) objID:(toobjid) class:outputClass
                        IF (conntype != "" AND NOT outputClass.empty) {
                            SET output:(outputs[conntype])
                            SET n:(aappend(output, STR toobjid))
                            SET outputs[conntype]:(output)
                        }
                    }
                    SET outputIds:(node["outputIds"])
                    SET outKeys:(mapKeysArray(outputs))
                    FOR i from:0 to:(outKeys.length-1) {
                        SET n:(aappend(outputIds, outputs[outKeys[i]]))
                    }
                    SET node["outputIds"]:(outputIds)
                }
                IF (node["meta"]["category"] = "trigger") {
                    SET meta["uiId"]:(obj)
                    SET node["meta"]:(meta)
                    SET n:(aappend(triggers, node))
                    SET resources["triggers"]:(triggers)
                } ELSE {
                    SET node["id"]:(obj)
                    SET node["meta"]:(meta)
                    SET n:(aappend(nodes, node))
                    SET resources["nodes"]:(nodes)
                }
            }
            SET workflowResources[0]:(resources)
            SET workflow["resources"]:(workflowResources)
        }

        SET path:(path + "\\" + applicationName)
        CC "AdoScript" DIR_CREATE path:(path)
        SET path:(path + "\\workflows")
        CC "AdoScript" DIR_CREATE path:(path)
        CC "AdoScript" FWRITE file:(path + "\\" + workflowName + ".json") text:(lam_toJson(workflow))
    }
}

PROCEDURE global LOSANT_DEVICES 
    objID:integer
    struct:reference
{
    SETL device:(map())
    SETL children:({})
    SETL attributes:({})
    SETL tags:({})
    SETL attributeTags:(map())
    CC "Core" GET_CLASS_ID objid:(objID)
    CC "Core" GET_CLASS_NAME classid:(classid)

    IF (classname = "system") {
        CC "Core" GET_ATTR_VAL objid:(objID) attrname:("name")
        SETL name:(val)
        IF (name != "") {
            SETL device["id"]:("~exportplaceholderid-system-name-" + STR objID + "~")
            SETL device["name"]:(name)
            SETL device["deviceClass"]:("system")
            CC "Core" GET_CONNECTORS objid:(objID) out
            SETL connids:(objids)
            FOR connid in:(connids) {
                SETL obj:(map())
                CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL connid)
                LOSANT_DEVICES objID:(toobjid) struct:obj
                IF (obj.empty = 0) {
                    CC "Core" GET_CLASS_ID relation objid:(VAL connid)
                    CC "Core" GET_CLASS_NAME classid:(classid)
                    IF (classname = "hasDevice" OR classname = "subsystem") {
                        SET n:(aappend(children, obj))
                    } ELSIF (classname = "hasAttribute" OR classname = "hasLocation" OR classname = "hasService") {
                        SET n:(aappend(attributes, obj))
                    }
                }
            }
            SETL device["children"]:(children)
            SETL device["attributes"]:(attributes)
            SETL device["tags"]:(tags)
        }
    } ELSIF (classname = "device") {
        CC "Core" GET_ATTR_VAL objid:(objID) attrname:("name")
        SETL name:(val)
        CC "Core" GET_ATTR_VAL objid:(objID) attrname:("psm_type")
        SETL deviceClass:(val)
        IF (name != "" AND deviceClass != "") {
            SETL device["id"]:("~exportplaceholderid-device-name-" + STR objID + "~")
            SETL device["name"]:(name)
            SETL device["deviceClass"]:(deviceClass)
            CC "Core" GET_CONNECTORS objid:(objID) out
            SETL connids:(objids)
            FOR connid in:(connids) {
                SETL obj:(map())
                CC "Core" GET_CONNECTOR_ENDPOINTS objid:(VAL connid)
                LOSANT_DEVICES objID:(toobjid) struct:obj
                IF (obj.empty = 0) {
                    CC "Core" GET_CLASS_ID relation objid:(VAL connid)
                    CC "Core" GET_CLASS_NAME classid:(classid)
                    IF (classname = "hasAttribute" OR classname = "hasLocation" OR classname = "hasService") {
                        SET n:(aappend(attributes, obj))
                    }
                }
            }
            SETL device["children"]:(children)
            SETL device["attributes"]:(attributes)
            SETL device["tags"]:(tags)
        }
    } ELSIF (classname = "attribute") {
        CC "Core" GET_ATTR_VAL objid:(objID) attrname:("name")
        SETL attrName:(val)
        SETL attrType:("")
        CC "Core" GET_ATTR_VAL objid:(objID) attrname:("type")
        IF (val = "boolean") {
            SET attrType:("boolean")
        } ELSIF (val = "string") {
            SET attrType:("string")
        } ELSIF (val = "numeric") {
            SET attrType:("number")
        }
        IF (attrName != "" AND attrType != "") {
            SETL device["name"]:(attrName)
            SETL device["dataType"]:(attrType)
            SETL device["attributeTags"]:(attributeTags)
        }
    } ELSIF (classname = "location") {
        CC "Core" GET_ATTR_VAL objid:(objID) attrname:("name")
        SETL device["name"]:("position")
        SETL device["dataType"]:("gps")
        SETL device["attributeTags"]:(attributeTags)
    }

    SETL struct:(device)
}